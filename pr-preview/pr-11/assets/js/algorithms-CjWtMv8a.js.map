{"version":3,"file":"algorithms-CjWtMv8a.js","sources":["../../../src/lib/utils/constants.ts","../../../src/lib/algorithms/imageProcessor.ts","../../../src/lib/math/geometry.ts","../../../src/lib/algorithms/pinCalculation.ts","../../../src/lib/math/interpolation.ts","../../../src/lib/algorithms/lineOptimization.ts","../../../src/lib/algorithms/yarnConversion.ts","../../../src/lib/algorithms/stringArtEngine.ts"],"sourcesContent":["/**\n * Default configuration constants for String Art Generation\n * Extracted from the original implementation\n */\n\nexport const DEFAULT_CONFIG = {\n  // Image processing\n  IMG_SIZE: 500,\n  SCALE: 20,\n  \n  // String art parameters\n  N_PINS: 288, // 36 * 8\n  MAX_LINES: 4000,\n  LINE_WEIGHT: 20,\n  MIN_DISTANCE: 20,\n  MIN_LOOP: 20,\n  \n  // Physical measurements\n  HOOP_DIAMETER: 0.625, // inches\n  \n  // Algorithm parameters\n  OPTIMIZATION_BATCH_SIZE: 10, // How often to redraw during optimization\n  CANVAS_SCALE_FACTOR: 2, // Scale factor for output canvas\n} as const;\n\nexport const GRAYSCALE_WEIGHTS = {\n  RED: 0.299,\n  GREEN: 0.587,\n  BLUE: 0.114,\n} as const;\n\nexport const CANVAS_CONTEXTS = {\n  ORIGINAL: 'canvasOutput',\n  PROCESSED: 'canvasOutput2',\n  INTERACTIVE: 'canvasOutput3',\n} as const;\n\nexport type StringArtConfig = typeof DEFAULT_CONFIG;","/**\n * Image processing utilities for String Art generation\n * Extracted from the original implementation\n */\n\nimport type { GrayscaleWeights, ProcessedImageData } from '../../types';\nimport { DEFAULT_CONFIG, GRAYSCALE_WEIGHTS } from '../utils/constants';\n\n/**\n * Crop image to square format, centered\n * Extracted from the original cropping logic\n */\nexport function cropToSquare(\n  imageElement: HTMLImageElement,\n  targetSize: number = DEFAULT_CONFIG.IMG_SIZE\n): ImageData {\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d')!;\n  \n  canvas.width = targetSize;\n  canvas.height = targetSize;\n  \n  const { width: imgWidth, height: imgHeight } = imageElement;\n  \n  // Calculate crop region for square center crop\n  let selectedWidth: number;\n  let selectedHeight: number;\n  let xOffset = 0;\n  let yOffset = 0;\n  \n  if (imgHeight > imgWidth) {\n    selectedWidth = imgWidth;\n    selectedHeight = imgWidth;\n    yOffset = Math.floor((imgHeight - imgWidth) / 2);\n  } else if (imgWidth > imgHeight) {\n    selectedWidth = imgHeight;\n    selectedHeight = imgHeight;\n    xOffset = Math.floor((imgWidth - imgHeight) / 2);\n  } else {\n    selectedWidth = imgWidth;\n    selectedHeight = imgHeight;\n  }\n  \n  // Draw cropped and scaled image\n  ctx.drawImage(\n    imageElement,\n    xOffset, yOffset, selectedWidth, selectedHeight,\n    0, 0, targetSize, targetSize\n  );\n  \n  return ctx.getImageData(0, 0, targetSize, targetSize);\n}\n\n/**\n * Convert image to grayscale using weighted formula\n * Extracted from the original grayscale conversion\n */\nexport function convertToGrayscale(\n  imageData: ImageData,\n  weights: GrayscaleWeights = { red: GRAYSCALE_WEIGHTS.RED, green: GRAYSCALE_WEIGHTS.GREEN, blue: GRAYSCALE_WEIGHTS.BLUE }\n): ImageData {\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d')!;\n  \n  canvas.width = imageData.width;\n  canvas.height = imageData.height;\n  \n  // Create a copy of the image data\n  const processedData = ctx.createImageData(imageData.width, imageData.height);\n  const data = processedData.data;\n  const originalData = imageData.data;\n  \n  // Apply weighted grayscale conversion\n  for (let i = 0; i < originalData.length; i += 4) {\n    const r = originalData[i];\n    const g = originalData[i + 1];\n    const b = originalData[i + 2];\n    const a = originalData[i + 3];\n    \n    // Calculate grayscale value using weighted formula\n    const gray = Math.round(\n      weights.red * r +\n      weights.green * g +\n      weights.blue * b\n    );\n    \n    // Set all color channels to the grayscale value\n    data[i] = gray;     // Red\n    data[i + 1] = gray; // Green\n    data[i + 2] = gray; // Blue\n    data[i + 3] = a;    // Alpha (unchanged)\n  }\n  \n  return processedData;\n}\n\n/**\n * Apply circular mask to image data\n * Extracted from the original circular masking logic\n */\nexport function applyCircularMask(imageData: ImageData): ImageData {\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d')!;\n  \n  canvas.width = imageData.width;\n  canvas.height = imageData.height;\n  \n  // Draw the image data to canvas\n  ctx.putImageData(imageData, 0, 0);\n  \n  // Apply circular mask using destination-in composite operation\n  ctx.globalCompositeOperation = 'destination-in';\n  ctx.beginPath();\n  ctx.arc(\n    imageData.width / 2,\n    imageData.height / 2,\n    imageData.width / 2,\n    0,\n    Math.PI * 2\n  );\n  ctx.closePath();\n  ctx.fill();\n  \n  return ctx.getImageData(0, 0, imageData.width, imageData.height);\n}\n\n/**\n * Process image through the complete pipeline\n * Crop -> Grayscale -> Circular Mask\n */\nexport function processImageForStringArt(\n  imageElement: HTMLImageElement,\n  targetSize: number = DEFAULT_CONFIG.IMG_SIZE\n): ProcessedImageData {\n  // Step 1: Crop to square\n  const croppedImageData = cropToSquare(imageElement, targetSize);\n  \n  // Step 2: Convert to grayscale\n  const grayscaleImageData = convertToGrayscale(croppedImageData);\n  \n  // Step 3: Apply circular mask\n  const circularMaskedImageData = applyCircularMask(grayscaleImageData);\n  \n  return {\n    originalImage: imageElement,\n    croppedImage: {\n      data: croppedImageData.data,\n      width: croppedImageData.width,\n      height: croppedImageData.height,\n    },\n    grayscaleImage: {\n      data: grayscaleImageData.data,\n      width: grayscaleImageData.width,\n      height: grayscaleImageData.height,\n    },\n    circularMaskedImage: {\n      data: circularMaskedImageData.data,\n      width: circularMaskedImageData.width,\n      height: circularMaskedImageData.height,\n    },\n    dimensions: {\n      width: targetSize,\n      height: targetSize,\n    },\n  };\n}\n\n/**\n * Convert ImageData to a 2D array for algorithm processing\n */\nexport function imageDataTo2DArray(imageData: ImageData): number[][] {\n  const { width, height, data } = imageData;\n  const result: number[][] = [];\n  \n  for (let y = 0; y < height; y++) {\n    const row: number[] = [];\n    for (let x = 0; x < width; x++) {\n      const index = (y * width + x) * 4;\n      // Use the red channel (since it's grayscale, all channels should be the same)\n      row.push(data[index]);\n    }\n    result.push(row);\n  }\n  \n  return result;\n}\n\n/**\n * Convert ImageData to a flat 1D array for algorithm processing\n */\nexport function imageDataToFlatArray(imageData: ImageData): Uint8Array {\n  const { width, height, data } = imageData;\n  const result = new Uint8Array(width * height);\n  \n  for (let i = 0; i < width * height; i++) {\n    // Use the red channel (since it's grayscale, all channels should be the same)\n    result[i] = data[i * 4];\n  }\n  \n  return result;\n}\n\n/**\n * Validate image dimensions\n */\nexport function validateImageDimensions(image: HTMLImageElement): {\n  isValid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n  \n  if (image.width < 100 || image.height < 100) {\n    errors.push('Image dimensions must be at least 100x100 pixels');\n  }\n  \n  if (image.width > 4000 || image.height > 4000) {\n    errors.push('Image dimensions should not exceed 4000x4000 pixels for performance reasons');\n  }\n  \n  const aspectRatio = image.width / image.height;\n  if (aspectRatio > 3 || aspectRatio < 1/3) {\n    errors.push('Image aspect ratio is too extreme. Consider using a more square image');\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n}","/**\n * Geometric utility functions for String Art generation\n * Extracted from the original implementation\n */\n\nimport type { Point, PinCoordinate } from '../../types';\n\n/**\n * Calculate the Euclidean distance between two points\n */\nexport function calculateDistance(p1: Point, p2: Point): number {\n  const dx = p2.x - p1.x;\n  const dy = p2.y - p1.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n/**\n * Calculate the distance between two pin coordinates\n */\nexport function calculatePinDistance(pin1: PinCoordinate, pin2: PinCoordinate): number {\n  const dx = pin2[0] - pin1[0];\n  const dy = pin2[1] - pin1[1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n/**\n * Calculate pin positions around a circle\n * Extracted from NonBlockingCalculatePins function\n */\nexport function calculatePinPositions(\n  numberOfPins: number,\n  center: number,\n  radius: number\n): PinCoordinate[] {\n  const pinCoords: PinCoordinate[] = [];\n  \n  for (let i = 0; i < numberOfPins; i++) {\n    const angle = (2 * Math.PI * i) / numberOfPins;\n    const x = Math.floor(center + radius * Math.cos(angle));\n    const y = Math.floor(center + radius * Math.sin(angle));\n    pinCoords.push([x, y]);\n  }\n  \n  return pinCoords;\n}\n\n/**\n * Check if a point is inside a circle\n */\nexport function isPointInCircle(\n  point: Point,\n  center: Point,\n  radius: number\n): boolean {\n  const distance = calculateDistance(point, center);\n  return distance <= radius;\n}\n\n/**\n * Convert degrees to radians\n */\nexport function degreesToRadians(degrees: number): number {\n  return (degrees * Math.PI) / 180;\n}\n\n/**\n * Convert radians to degrees\n */\nexport function radiansToDegrees(radians: number): number {\n  return (radians * 180) / Math.PI;\n}\n\n/**\n * Normalize an angle to be within 0 to 2� radians\n */\nexport function normalizeAngle(angle: number): number {\n  while (angle < 0) {\n    angle += 2 * Math.PI;\n  }\n  while (angle >= 2 * Math.PI) {\n    angle -= 2 * Math.PI;\n  }\n  return angle;\n}","/**\n * Pin calculation algorithm for String Art generation\n * Extracted from NonBlockingCalculatePins function\n */\n\nimport type { PinCoordinate, StringArtParameters } from '../../types';\nimport { calculatePinPositions } from '../math/geometry';\nimport { DEFAULT_CONFIG } from '../utils/constants';\n\n/**\n * Calculate pin coordinates around a circular boundary\n */\nexport function calculatePins(params: Partial<StringArtParameters> = {}): PinCoordinate[] {\n  const {\n    numberOfPins = DEFAULT_CONFIG.N_PINS,\n    imgSize = DEFAULT_CONFIG.IMG_SIZE,\n  } = params;\n\n  const center = imgSize / 2;\n  const radius = imgSize / 2 - 0.5; // Leave half-pixel margin\n\n  return calculatePinPositions(numberOfPins, center, radius);\n}\n\n/**\n * Validate pin parameters\n */\nexport function validatePinParameters(params: Partial<StringArtParameters>): {\n  isValid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n  \n  if (params.numberOfPins !== undefined) {\n    if (params.numberOfPins < 3) {\n      errors.push('Number of pins must be at least 3');\n    }\n    if (params.numberOfPins > 1000) {\n      errors.push('Number of pins should not exceed 1000 for performance reasons');\n    }\n    if (!Number.isInteger(params.numberOfPins)) {\n      errors.push('Number of pins must be an integer');\n    }\n  }\n\n  if (params.imgSize !== undefined) {\n    if (params.imgSize < 100) {\n      errors.push('Image size must be at least 100 pixels');\n    }\n    if (params.imgSize > 2000) {\n      errors.push('Image size should not exceed 2000 pixels for performance reasons');\n    }\n    if (!Number.isInteger(params.imgSize)) {\n      errors.push('Image size must be an integer');\n    }\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n}\n\n/**\n * Calculate the angular separation between adjacent pins\n */\nexport function calculateAngularSeparation(numberOfPins: number): number {\n  return (2 * Math.PI) / numberOfPins;\n}\n\n/**\n * Get the pin index that is at a specific angle offset from a given pin\n */\nexport function getPinAtOffset(\n  currentPin: number,\n  offset: number,\n  numberOfPins: number\n): number {\n  return (currentPin + offset) % numberOfPins;\n}\n\n/**\n * Calculate the minimum distance between two pins (in terms of pin indices)\n */\nexport function calculateMinPinDistance(\n  pin1: number,\n  pin2: number,\n  numberOfPins: number\n): number {\n  const direct = Math.abs(pin2 - pin1);\n  const wraparound = numberOfPins - direct;\n  return Math.min(direct, wraparound);\n}\n\n/**\n * Get all pins within a minimum distance range from a given pin\n */\nexport function getValidTargetPins(\n  currentPin: number,\n  minDistance: number,\n  numberOfPins: number,\n  excludePins: number[] = []\n): number[] {\n  const validPins: number[] = [];\n  \n  for (let offset = minDistance; offset < numberOfPins - minDistance; offset++) {\n    const targetPin = getPinAtOffset(currentPin, offset, numberOfPins);\n    \n    if (!excludePins.includes(targetPin)) {\n      validPins.push(targetPin);\n    }\n  }\n  \n  return validPins;\n}","/**\n * Interpolation utility functions\n * Extracted from the original implementation\n */\n\n/**\n * Generate linearly spaced numbers between two values\n * Extracted from the original linspace function\n */\nexport function linspace(start: number, stop: number, num?: number): number[] {\n  const n = typeof num === 'undefined' ? Math.max(Math.round(stop - start) + 1, 1) : num;\n  \n  if (n < 2) {\n    return n === 1 ? [start] : [];\n  }\n  \n  const result: number[] = new Array(n);\n  const step = (stop - start) / (n - 1);\n  \n  for (let i = 0; i < n; i++) {\n    result[i] = Math.floor(start + step * i);\n  }\n  \n  return result;\n}\n\n/**\n * Linear interpolation between two values\n */\nexport function lerp(start: number, end: number, t: number): number {\n  return start + (end - start) * t;\n}\n\n/**\n * Inverse linear interpolation - find t value for a given interpolated value\n */\nexport function inverseLerp(start: number, end: number, value: number): number {\n  if (start === end) return 0;\n  return (value - start) / (end - start);\n}\n\n/**\n * Clamp a value between min and max\n */\nexport function clamp(value: number, min: number, max: number): number {\n  return Math.min(Math.max(value, min), max);\n}\n\n/**\n * Smooth step interpolation (cubic hermite interpolation)\n */\nexport function smoothstep(edge0: number, edge1: number, x: number): number {\n  const t = clamp((x - edge0) / (edge1 - edge0), 0, 1);\n  return t * t * (3 - 2 * t);\n}\n\n/**\n * Bi-linear interpolation for 2D values\n */\nexport function bilinearInterpolation(\n  x: number,\n  y: number,\n  x1: number,\n  x2: number,\n  y1: number,\n  y2: number,\n  q11: number,\n  q12: number,\n  q21: number,\n  q22: number\n): number {\n  const r1 = lerp(q11, q21, (x - x1) / (x2 - x1));\n  const r2 = lerp(q12, q22, (x - x1) / (x2 - x1));\n  return lerp(r1, r2, (y - y1) / (y2 - y1));\n}","/**\n * Line optimization algorithm for String Art generation\n * Extracted from NonBlockingPrecalculateLines and NonBlockingLineCalculator functions\n */\n\nimport type { PinCoordinate, LineCache, StringArtParameters, OptimizationProgress } from '../../types';\nimport { linspace } from '../math/interpolation';\n// Removed unused import: getSum\nimport { calculatePinDistance } from '../math/geometry';\nimport { getValidTargetPins } from './pinCalculation';\nimport { DEFAULT_CONFIG } from '../utils/constants';\n\n/**\n * Precalculate all possible lines between pins for optimization\n * Extracted from NonBlockingPrecalculateLines function\n */\nexport function precalculateLineCache(\n  pinCoords: PinCoordinate[],\n  minDistance: number = DEFAULT_CONFIG.MIN_DISTANCE\n): LineCache {\n  const numPins = pinCoords.length;\n  const cache: LineCache = {\n    x: new Array(numPins * numPins).fill(null),\n    y: new Array(numPins * numPins).fill(null),\n    length: new Array(numPins * numPins).fill(0),\n    weight: new Array(numPins * numPins).fill(1),\n  };\n\n  for (let a = 0; a < numPins; a++) {\n    for (let b = a + minDistance; b < numPins; b++) {\n      const [x0, y0] = pinCoords[a];\n      const [x1, y1] = pinCoords[b];\n\n      // Calculate line length\n      const distance = Math.floor(calculatePinDistance(pinCoords[a], pinCoords[b]));\n\n      // Generate line coordinates using linear interpolation\n      const xs = linspace(x0, x1, distance);\n      const ys = linspace(y0, y1, distance);\n\n      // Store in both directions (a->b and b->a)\n      const indexAB = a * numPins + b;\n      const indexBA = b * numPins + a;\n\n      cache.x[indexAB] = xs;\n      cache.x[indexBA] = xs;\n      cache.y[indexAB] = ys;\n      cache.y[indexBA] = ys;\n      cache.length[indexAB] = distance;\n      cache.length[indexBA] = distance;\n    }\n  }\n\n  return cache;\n}\n\n/**\n * Calculate error for a specific line on the error matrix\n * Extracted from getLineErr function\n */\nexport function calculateLineError(\n  errorMatrix: Float32Array | Uint8Array,\n  lineCoords: { x: number[]; y: number[] },\n  imgWidth: number\n): number {\n  const { x: xs, y: ys } = lineCoords;\n  let totalError = 0;\n\n  for (let i = 0; i < xs.length; i++) {\n    const pixelIndex = ys[i] * imgWidth + xs[i];\n    if (pixelIndex >= 0 && pixelIndex < errorMatrix.length) {\n      totalError += errorMatrix[pixelIndex];\n    }\n  }\n\n  return totalError;\n}\n\n/**\n * Apply line mask to error matrix (subtract line from error)\n * Extracted from setLine function\n */\nexport function applyLineMask(\n  errorMatrix: Float32Array,\n  lineCoords: { x: number[]; y: number[] },\n  lineWeight: number,\n  imgWidth: number\n): void {\n  const { x: xs, y: ys } = lineCoords;\n\n  for (let i = 0; i < xs.length; i++) {\n    const pixelIndex = ys[i] * imgWidth + xs[i];\n    if (pixelIndex >= 0 && pixelIndex < errorMatrix.length) {\n      let newValue = errorMatrix[pixelIndex] - lineWeight;\n      \n      // Clamp to valid range\n      if (newValue < 0) newValue = 0;\n      if (newValue > 255) newValue = 255;\n      \n      errorMatrix[pixelIndex] = newValue;\n    }\n  }\n}\n\n/**\n * Find the best next pin for the optimization algorithm\n * Extracted from the core optimization loop\n */\nexport function findBestNextPin(\n  currentPin: number,\n  errorMatrix: Float32Array,\n  lineCache: LineCache,\n  lastPins: number[],\n  params: StringArtParameters\n): { bestPin: number; error: number } {\n  let maxError = -1;\n  let bestPin = -1;\n\n  const validPins = getValidTargetPins(\n    currentPin,\n    params.minDistance,\n    params.numberOfPins,\n    lastPins\n  );\n\n  for (const testPin of validPins) {\n    const cacheIndex = testPin * params.numberOfPins + currentPin;\n    const xs = lineCache.x[cacheIndex];\n    const ys = lineCache.y[cacheIndex];\n\n    if (xs && ys) {\n      const lineError = calculateLineError(\n        errorMatrix,\n        { x: xs, y: ys },\n        params.imgSize\n      ) * lineCache.weight[cacheIndex];\n\n      if (lineError > maxError) {\n        maxError = lineError;\n        bestPin = testPin;\n      }\n    }\n  }\n\n  return { bestPin, error: maxError };\n}\n\n/**\n * Main optimization algorithm\n * Extracted from NonBlockingLineCalculator function\n */\nexport async function optimizeStringArt(\n  errorMatrix: Float32Array,\n  pinCoords: PinCoordinate[],\n  lineCache: LineCache,\n  params: StringArtParameters,\n  onProgress?: (progress: OptimizationProgress, currentLineSequence?: number[], pinCoordinates?: PinCoordinate[]) => void\n): Promise<{\n  lineSequence: number[];\n  totalThreadLength: number;\n}> {\n  const lineSequence: number[] = [];\n  let currentPin = 0;\n  let totalThreadLength = 0;\n  const lastPins: number[] = [];\n  \n  lineSequence.push(currentPin);\n\n  for (let lineIndex = 0; lineIndex < params.numberOfLines; lineIndex++) {\n    // Find best next pin\n    const { bestPin } = findBestNextPin(\n      currentPin,\n      errorMatrix,\n      lineCache,\n      lastPins,\n      params\n    );\n\n    if (bestPin === -1) {\n      console.warn('No valid next pin found, stopping optimization');\n      break;\n    }\n\n    // Add to sequence\n    lineSequence.push(bestPin);\n\n    // Apply the line to the error matrix\n    const cacheIndex = bestPin * params.numberOfPins + currentPin;\n    const xs = lineCache.x[cacheIndex];\n    const ys = lineCache.y[cacheIndex];\n\n    if (xs && ys) {\n      applyLineMask(errorMatrix, { x: xs, y: ys }, params.lineWeight, params.imgSize);\n    }\n\n    // Calculate thread length\n    const distance = calculatePinDistance(pinCoords[currentPin], pinCoords[bestPin]);\n    totalThreadLength += (params.hoopDiameter / params.imgSize) * distance;\n\n    // Update last pins (prevent immediate backtracking)\n    lastPins.push(bestPin);\n    if (lastPins.length > 20) {\n      lastPins.shift();\n    }\n\n    currentPin = bestPin;\n\n    // Report progress (every 10 lines like original, not every OPTIMIZATION_BATCH_SIZE)\n    if (onProgress && (lineIndex % 10 === 0 || lineIndex === params.numberOfLines - 1)) {\n      console.log(`Line ${lineIndex + 1}/${params.numberOfLines}: Calling progress callback`)\n      \n      const progress: OptimizationProgress = {\n        linesDrawn: lineIndex + 1,\n        totalLines: params.numberOfLines,\n        percentComplete: ((lineIndex + 1) / params.numberOfLines) * 100,\n        currentPin: currentPin,\n        nextPin: bestPin,\n        threadLength: totalThreadLength,\n      };\n      \n      // Pass current line sequence and pin coordinates for progressive drawing\n      onProgress(progress, [...lineSequence], pinCoords);\n      \n      // Yield control to prevent blocking\n      await new Promise(resolve => setTimeout(resolve, 0));\n    }\n  }\n\n  return {\n    lineSequence,\n    totalThreadLength,\n  };\n}\n\n/**\n * Initialize error matrix from processed image data\n */\nexport function createErrorMatrix(\n  processedImageData: Uint8Array,\n  imgSize: number\n): Float32Array {\n  const errorMatrix = new Float32Array(imgSize * imgSize);\n  \n  // Error = 255 - pixel_value (invert so darker pixels have higher error)\n  for (let i = 0; i < processedImageData.length; i++) {\n    errorMatrix[i] = 255 - processedImageData[i];\n  }\n  \n  return errorMatrix;\n}","\nimport type { YarnSpec } from '../../types/yarn';\n\n/**\n * Normalizes various yarn specifications into a canonical linear density Tex (g/1000m).\n * @param spec The user-provided yarn specification.\n * @returns The calculated Tex value.\n */\nexport function normalizeToTex(spec: YarnSpec): number {\n  const { type, ticketNo, nm, ply, tex, dtex, denier, meters, grams } = spec;\n  const safePly = ply || 1;\n\n  switch (type) {\n    case 'tex':\n      return tex || 0;\n\n    case 'dtex':\n      // Tex = dtex / 10\n      // If ply is provided, we assume input dtex is per-ply if it's common notation,\n      // but usually dtex is total. Prompt says \"dtex: [dtex] + optional [ply] OR total dtex\".\n      // We'll treat the entered dtex as \"per strand\" if ply > 1, or total if ply is 1/undefined.\n      // Wait, prompt says: \"dtex 141*2 -> 282 dtex -> Tex 28.2\".\n      // So if ply is specified, we multiply.\n      return ((dtex || 0) * safePly) / 10;\n\n    case 'denier':\n      // Tex = Denier / 9\n      return ((denier || 0) * safePly) / 9;\n\n    case 'nm':\n      // Tex = 1000 / Nm\n      // Nm is usually length per weight (m/g).\n      // Nm 71/2 means Nm 71 (single) with 2 plies.\n      // Resulting Nm_total = Nm_single / ply = 71/2 = 35.5\n      // Tex = 1000 / Nm_total = 1000 / (Nm_single / ply) = (1000 * ply) / Nm_single\n      if (!nm || nm === 0) return 0;\n      return (1000 * safePly) / nm;\n\n    case 'length_weight':\n      // Tex = (g / m) * 1000\n      if (!meters || meters === 0) return 0;\n      return ((grams || 0) / meters) * 1000;\n\n    case 'ticket':\n      // Tex ≈ 3000 / TicketNo (Approximation)\n      if (!ticketNo || ticketNo === 0) return 0;\n      return 3000 / ticketNo;\n\n    case 'diameter_mm':\n      // Cannot convert directly to Tex without density assumption, handled separately or unused for Tex calculation\n      return 0;\n\n    default:\n      return 0;\n  }\n}\n\n/**\n * Calculates the estimated physical diameter in millimeters.\n * @param spec The user-provided yarn specification.\n * @returns The estimated diameter in mm.\n */\nexport function calculateDiameterMM(spec: YarnSpec): number {\n  const { type, material, diameterMM, overrideDiameterMM } = spec;\n\n  // 1. If override is provided, use it.\n  if (overrideDiameterMM && overrideDiameterMM > 0) {\n    return overrideDiameterMM;\n  }\n\n  // 2. If type is 'diameter_mm', use it.\n  if (type === 'diameter_mm') {\n    return diameterMM || 0;\n  }\n\n  // 3. Calculate from Tex\n  const tex = normalizeToTex(spec);\n  if (tex <= 0) return 0;\n\n  // Density rho [kg/m^3]\n  let rho = 1380; // Polyester default\n\n  switch (material) {\n    case 'cotton':\n      rho = 1540;\n      break;\n    case 'nylon':\n      rho = 1140;\n      break;\n    case 'polyester':\n    case 'unknown':\n    default:\n      rho = 1380;\n      break;\n  }\n\n  // massPerLength [kg/m] = Tex [g/1000m] * 1e-6 (g to kg, 1000m normalization)\n  // Wait. Tex = g / 1000m.\n  // 1 Tex = 1g / 1000m = 0.001 kg / 1000m = 1e-6 kg/m.\n  const massPerLength = tex * 1e-6;\n\n  // area [m^2] = massPerLength / rho\n  const area = massPerLength / rho;\n\n  // diameter_m = 2 * sqrt(area / π)\n  const diameter_m = 2 * Math.sqrt(area / Math.PI);\n\n  // diameterMM\n  return diameter_m * 1000;\n}\n\n/**\n * Calculates the effective thread thickness in millimeters, including the visual multiplier k.\n * @param spec The user-provided yarn specification.\n * @returns The effective thread thickness in mm.\n */\nexport function calculateThreadThicknessMM(spec: YarnSpec): number {\n  const diameterMM = calculateDiameterMM(spec);\n\n  // Apply k multiplier (default 1.10)\n  // Note: if the user explicitly provided diameter, we might still want to apply k?\n  // The prompt says: \"If user chose 'Diameter in mm' or used 'Override diameter', skip the physics and set threadThicknessMM directly (still apply k only if you want, but be consistent and document it).\"\n  // Let's apply k to everything to allow fine tuning \"fuzziness\" even for explicit diameters.\n  const k = spec.k || 1.10;\n\n  return diameterMM * k;\n}\n\n/**\n * Calculates the lineWeight (1..255) based on thread thickness and frame parameters.\n * @param threadThicknessMM The effective thread thickness in mm.\n * @param hoopDiameterMM The frame/hoop diameter in mm.\n * @param imgSizePx The image size in pixels.\n * @returns The calculated lineWeight (opacity 1..255).\n */\nexport function calculateLineWeight(\n  threadThicknessMM: number,\n  hoopDiameterMM: number,\n  imgSizePx: number\n): number {\n  if (imgSizePx <= 0 || hoopDiameterMM <= 0) return 1;\n\n  const pixelSizeMM = hoopDiameterMM / imgSizePx;\n  const opacity = (threadThicknessMM / pixelSizeMM) * 255;\n\n  // clamp(1..255, round(opacity))\n  return Math.max(1, Math.min(255, Math.round(opacity)));\n}\n","/**\n * Main String Art Engine\n * Coordinates all algorithms to generate string art from an image\n */\n\nimport type { StringArtParameters, StringArtResult, OptimizationProgress } from '../../types';\nimport { processImageForStringArt, imageDataToFlatArray } from './imageProcessor';\nimport { calculatePins } from './pinCalculation';\nimport { precalculateLineCache, optimizeStringArt, createErrorMatrix } from './lineOptimization';\nimport { DEFAULT_CONFIG } from '../utils/constants';\nimport { calculateThreadThicknessMM, calculateLineWeight } from './yarnConversion';\n\n/**\n * Main function to generate string art from an image\n */\nexport async function generateStringArt(\n  imageElement: HTMLImageElement,\n  params: Partial<StringArtParameters> = {},\n  onProgress?: (progress: OptimizationProgress, currentLineSequence?: number[], pinCoordinates?: [number, number][]) => void\n): Promise<StringArtResult> {\n  const startTime = Date.now();\n\n  // Calculate lineWeight from yarnSpec if present\n  let lineWeight = params.lineWeight ?? DEFAULT_CONFIG.LINE_WEIGHT;\n  if (params.yarnSpec) {\n    const threadThicknessMM = calculateThreadThicknessMM(params.yarnSpec);\n    const hoopDiameter = params.hoopDiameter ?? (DEFAULT_CONFIG.HOOP_DIAMETER * 25.4);\n    const imgSize = params.imgSize ?? DEFAULT_CONFIG.IMG_SIZE;\n    lineWeight = calculateLineWeight(threadThicknessMM, hoopDiameter, imgSize);\n  }\n\n  // Merge with default parameters\n  const parameters: StringArtParameters = {\n    numberOfPins: params.numberOfPins ?? DEFAULT_CONFIG.N_PINS,\n    numberOfLines: params.numberOfLines ?? DEFAULT_CONFIG.MAX_LINES,\n    lineWeight: lineWeight,\n    minDistance: params.minDistance ?? DEFAULT_CONFIG.MIN_DISTANCE,\n    imgSize: params.imgSize ?? DEFAULT_CONFIG.IMG_SIZE,\n    scale: params.scale ?? DEFAULT_CONFIG.SCALE,\n    hoopDiameter: params.hoopDiameter ?? (DEFAULT_CONFIG.HOOP_DIAMETER * 25.4),\n    yarnSpec: params.yarnSpec,\n  };\n\n  // Step 1: Process the image\n  console.log('Processing image...');\n  const processedImageData = processImageForStringArt(imageElement, parameters.imgSize);\n  \n  // Step 2: Calculate pin positions\n  console.log('Calculating pin positions...');\n  const pinCoordinates = calculatePins(parameters);\n\n  // Step 3: Precalculate line cache\n  console.log('Precalculating lines...');\n  const lineCache = precalculateLineCache(pinCoordinates, parameters.minDistance);\n\n  // Step 4: Create error matrix from processed image\n  console.log('Creating error matrix...');\n  const imageArray = imageDataToFlatArray({\n    data: processedImageData.circularMaskedImage.data,\n    width: processedImageData.circularMaskedImage.width,\n    height: processedImageData.circularMaskedImage.height,\n  } as ImageData);\n  const errorMatrix = createErrorMatrix(imageArray, parameters.imgSize);\n\n  // Step 5: Optimize string art\n  console.log('Optimizing string art...');\n  const { lineSequence, totalThreadLength } = await optimizeStringArt(\n    errorMatrix,\n    pinCoordinates,\n    lineCache,\n    parameters,\n    onProgress\n  );\n\n  const processingTimeMs = Date.now() - startTime;\n\n  return {\n    lineSequence,\n    pinCoordinates,\n    totalThreadLength,\n    parameters,\n    processingTimeMs,\n  };\n}\n\n/**\n * Validate parameters before processing\n */\nexport function validateStringArtParameters(params: Partial<StringArtParameters>): {\n  isValid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  if (params.numberOfPins !== undefined) {\n    if (params.numberOfPins < 3) errors.push('Number of pins must be at least 3');\n    if (params.numberOfPins > 1000) errors.push('Number of pins should not exceed 1000');\n    if (!Number.isInteger(params.numberOfPins)) errors.push('Number of pins must be an integer');\n  }\n\n  if (params.numberOfLines !== undefined) {\n    if (params.numberOfLines < 1) errors.push('Number of lines must be at least 1');\n    if (params.numberOfLines > 10000) errors.push('Number of lines should not exceed 10000');\n    if (!Number.isInteger(params.numberOfLines)) errors.push('Number of lines must be an integer');\n  }\n\n  if (params.lineWeight !== undefined) {\n    if (params.lineWeight < 1) errors.push('Line weight must be at least 1');\n    if (params.lineWeight > 100) errors.push('Line weight should not exceed 100');\n  }\n\n  if (params.minDistance !== undefined) {\n    if (params.minDistance < 1) errors.push('Minimum distance must be at least 1');\n    if (params.minDistance > 50) errors.push('Minimum distance should not exceed 50');\n  }\n\n  if (params.imgSize !== undefined) {\n    if (params.imgSize < 100) errors.push('Image size must be at least 100');\n    if (params.imgSize > 2000) errors.push('Image size should not exceed 2000');\n    if (!Number.isInteger(params.imgSize)) errors.push('Image size must be an integer');\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n}\n\n/**\n * Create default parameters with validation\n */\nexport function createDefaultParameters(overrides: Partial<StringArtParameters> = {}): StringArtParameters {\n  const defaults: StringArtParameters = {\n    numberOfPins: DEFAULT_CONFIG.N_PINS,\n    numberOfLines: DEFAULT_CONFIG.MAX_LINES,\n    lineWeight: DEFAULT_CONFIG.LINE_WEIGHT,\n    minDistance: DEFAULT_CONFIG.MIN_DISTANCE,\n    imgSize: DEFAULT_CONFIG.IMG_SIZE,\n    scale: DEFAULT_CONFIG.SCALE,\n    hoopDiameter: DEFAULT_CONFIG.HOOP_DIAMETER,\n  };\n\n  return { ...defaults, ...overrides };\n}"],"names":["DEFAULT_CONFIG","GRAYSCALE_WEIGHTS","cropToSquare","imageElement","targetSize","canvas","ctx","imgWidth","imgHeight","selectedWidth","selectedHeight","xOffset","yOffset","convertToGrayscale","imageData","weights","processedData","data","originalData","i","r","g","b","a","gray","applyCircularMask","processImageForStringArt","croppedImageData","grayscaleImageData","circularMaskedImageData","imageDataToFlatArray","width","height","result","calculatePinDistance","pin1","pin2","dx","dy","calculatePinPositions","numberOfPins","center","radius","pinCoords","angle","x","y","calculatePins","params","imgSize","getPinAtOffset","currentPin","offset","getValidTargetPins","minDistance","excludePins","validPins","targetPin","linspace","start","stop","num","n","step","precalculateLineCache","numPins","cache","x0","y0","x1","y1","distance","xs","ys","indexAB","indexBA","calculateLineError","errorMatrix","lineCoords","totalError","pixelIndex","applyLineMask","lineWeight","newValue","findBestNextPin","lineCache","lastPins","maxError","bestPin","testPin","cacheIndex","lineError","optimizeStringArt","onProgress","lineSequence","totalThreadLength","lineIndex","progress","resolve","createErrorMatrix","processedImageData","normalizeToTex","spec","type","ticketNo","nm","ply","tex","dtex","denier","meters","grams","safePly","calculateDiameterMM","material","diameterMM","overrideDiameterMM","rho","area","calculateThreadThicknessMM","k","calculateLineWeight","threadThicknessMM","hoopDiameterMM","imgSizePx","pixelSizeMM","opacity","generateStringArt","startTime","hoopDiameter","parameters","pinCoordinates","imageArray","processingTimeMs"],"mappings":"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"}